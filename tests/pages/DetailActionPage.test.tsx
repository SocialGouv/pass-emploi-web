import { act, fireEvent, screen, within } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { AxeResults } from 'axe-core'
import { axe } from 'jest-axe'
import { useRouter } from 'next/navigation'
import React from 'react'

import DetailActionPage from 'app/(connected)/(with-sidebar)/(with-chat)/mes-jeunes/[idJeune]/actions/[idAction]/DetailActionPage'
import { uneAction } from 'fixtures/action'
import { StatutAction } from 'interfaces/action'
import { BaseBeneficiaire } from 'interfaces/beneficiaire'
import { StructureConseiller } from 'interfaces/conseiller'
import { AlerteParam } from 'referentiel/alerteParam'
import { deleteAction, modifierAction } from 'services/actions.service'
import { commenterAction } from 'services/messages.service'
import getByDescriptionTerm from 'tests/querySelector'
import renderWithContexts from 'tests/renderWithContexts'

jest.mock('services/actions.service')
jest.mock('services/messages.service')
jest.mock('components/PageActionsPortal')

describe('ActionPage client side', () => {
  let container: HTMLElement
  let alerteSetter: (key: AlerteParam | undefined, target?: string) => void
  let routerPush: Function
  const action = uneAction()
  const jeune: BaseBeneficiaire & { idConseiller: string } = {
    id: 'beneficiaire-1',
    prenom: 'Nadia',
    nom: 'Sanfamiye',
    idConseiller: 'id-conseiller',
  }

  beforeEach(() => {
    alerteSetter = jest.fn()
    routerPush = jest.fn()
    ;(modifierAction as jest.Mock).mockImplementation(
      async (_, statut) => statut
    )
    ;(deleteAction as jest.Mock).mockResolvedValue(undefined)
    ;(useRouter as jest.Mock).mockReturnValue({
      push: routerPush,
    })
  })

  describe('render', () => {
    beforeEach(async () => {
      ;({ container } = renderWithContexts(
        <DetailActionPage
          action={action}
          jeune={jeune}
          lectureSeule={false}
          from='beneficiaire'
        />,
        {
          customAlerte: { setter: alerteSetter },
        }
      ))
    })

    it('a11y', async () => {
      let results: AxeResults

      await act(async () => {
        results = await axe(container)
      })

      expect(results!).toHaveNoViolations()
    })

    it("affiche les information d'une action", async () => {
      expect(getByDescriptionTerm('Description :')).toHaveTextContent(
        action.comment
      )

      await userEvent.click(
        Array.from(container.querySelectorAll('details summary')).find((el) =>
          /Historique/.test(el.textContent!)
        )!
      )
      expect(getByDescriptionTerm('Date de crÃ©ation :')).toHaveTextContent(
        '15/02/2022'
      )
      expect(getByDescriptionTerm('Date dâ€™actualisation :')).toHaveTextContent(
        '16/02/2022'
      )
      expect(getByDescriptionTerm("CrÃ©ateur de l'action :")).toHaveTextContent(
        action.creator
      )
    })

    describe('Au clique sur un statut', () => {
      it("dÃ©clenche le changement de statut de l'action", async () => {
        // Given
        const statutRadio = screen.getByText('Ã€ faire')

        // When
        await userEvent.click(statutRadio)

        // Then
        expect(modifierAction).toHaveBeenCalledWith(action.id, {
          statut: StatutAction.AFaire,
        })
      })
    })

    describe('Quand lâ€™action a le statut EnCours', () => {
      it('nâ€™affiche pas la date de rÃ©alisation', async () => {
        // Given
        const statutRadio = screen.getByText('Ã€ faire')

        // When
        await userEvent.click(statutRadio)

        // Then
        expect(() => screen.getByText('Date de rÃ©alisation :')).toThrow()
      })
    })

    describe('Quand lâ€™action passe en statut TerminÃ©e', () => {
      it('affiche la date de rÃ©alisation', async () => {
        // Given
        const statutRadio = screen.getByText('TerminÃ©e - Ã€ qualifier')

        // When
        await userEvent.click(statutRadio)

        // Then
        expect(screen.getByText('Date de rÃ©alisation :')).toBeInTheDocument()
      })
    })

    describe('Partage action', () => {
      let group: HTMLDetailsElement
      let boutonVoir: HTMLElement
      beforeEach(async () => {
        group = Array.from(container.querySelectorAll('details')).find((el) =>
          /Commentaire/.test(el.textContent!)
        ) as HTMLDetailsElement

        boutonVoir = group.querySelector('summary') as HTMLElement
      })

      it('est cachÃ© par dÃ©faut', async () => {
        // Then
        expect(group).not.toHaveAttribute('open')
      })

      describe('quand on ouvre lâ€™accordÃ©on', () => {
        beforeEach(async () => {
          // When
          await userEvent.click(boutonVoir)
        })

        it('demande la saisi dâ€™un message', async () => {
          expect(
            within(group).getByRole('textbox', {
              name: 'Demander plus dâ€™information au bÃ©nÃ©ficiaire sur lâ€™action',
            })
          ).toHaveValue(
            'Pouvez-vous complÃ©ter la description de cette action sâ€™il vous plaÃ®t ?'
          )
        })

        it('envoie un message', async () => {
          //
          expect(group).toHaveAttribute('open')

          // Given
          // FIXME pourquoi Ã§a marche pas avec userEvent.click ? ðŸ¤¨
          fireEvent.change(
            within(group).getByRole('textbox', {
              name: 'Demander plus dâ€™information au bÃ©nÃ©ficiaire sur lâ€™action',
            }),
            {
              target: {
                value:
                  'Peux tu me dÃ©tailler quelles recherches tu as fait stp ?',
              },
            }
          )

          // When
          await userEvent.click(
            within(group).getByRole('button', {
              name: 'Envoyer au bÃ©nÃ©ficiaire',
            })
          )

          // Then
          expect(commenterAction).toHaveBeenCalledWith({
            cleChiffrement: 'cleChiffrement',
            idDestinataire: jeune.id,
            message: 'Peux tu me dÃ©tailler quelles recherches tu as fait stp ?',
            action,
          })
          expect(document.activeElement).toHaveTextContent(
            'Votre message a bien Ã©tÃ© envoyÃ©, retrouvez le dans votre conversation avec le bÃ©nÃ©ficiaire.'
          )
        })

        it('a11y', async () => {
          // When
          let results: AxeResults

          await act(async () => {
            results = await axe(container)
          })

          expect(results!).toHaveNoViolations()
        })
      })
    })
  })

  describe("quand le conseiller n'est pas le conseiller du jeune", () => {
    ;(modifierAction as jest.Mock).mockImplementation(
      async (_, statut) => statut
    )
    ;(deleteAction as jest.Mock).mockResolvedValue({})

    beforeEach(async () => {
      ;({ container } = renderWithContexts(
        <DetailActionPage
          action={action}
          jeune={jeune}
          lectureSeule={true}
          from='beneficiaire'
        />,
        {
          customAlerte: { setter: alerteSetter },
          customConseiller: { id: 'fake-id' },
        }
      ))
    })

    it('a11y', async () => {
      let results: AxeResults

      await act(async () => {
        results = await axe(container)
      })

      expect(results!).toHaveNoViolations()
    })

    it('affiche un encart lecture seule si ce nâ€˜est pas le conseiller du jeune', async () => {
      //Then
      expect(screen.getByText('Vous Ãªtes en lecture seule')).toBeInTheDocument()
      expect(
        screen.getByText(
          'Vous pouvez uniquement lire le dÃ©tail de lâ€™action de ce bÃ©nÃ©ficiaire car il ne fait pas partie de votre portefeuille.'
        )
      ).toBeInTheDocument()
    })

    it('dÃ©sactive tous les boutons radio', async () => {
      const radioButtons = screen.getAllByRole('radio')
      radioButtons.forEach((radioBtn) => {
        expect(radioBtn).toHaveAttribute('disabled')
      })
    })

    it("n'affiche pas l'encart de crÃ©ation de commentaire", async () => {
      expect(() =>
        screen.getByText('Commentaire Ã  destination du jeune')
      ).toThrow()
      expect(() => screen.getByLabelText('Ajouter un commentaire')).toThrow()
      expect(() => screen.getByText('Ajouter un commentaire')).toThrow()
    })
  })

  describe("quand l'action est terminÃ©e et non qualifiÃ©e", () => {
    describe('quand le conseiller est MiLo', () => {
      const actionAQualifier = uneAction({
        status: StatutAction.Terminee,
      })
      const jeune: BaseBeneficiaire & { idConseiller: string } = {
        id: 'beneficiaire-1',
        prenom: 'Nadia',
        nom: 'Sanfamiye',
        idConseiller: 'id-conseiller',
      }

      beforeEach(async () => {
        ;(useRouter as jest.Mock).mockReturnValue({ push: routerPush })
      })

      it("affiche un lien pour qualifier l'action", async () => {
        //When
        renderWithContexts(
          <DetailActionPage
            action={actionAQualifier}
            jeune={jeune}
            lectureSeule={false}
            from='beneficiaire'
          />,
          {
            customConseiller: {
              structure: StructureConseiller.MILO,
            },
            customAlerte: { setter: alerteSetter },
          }
        )

        //Then
        expect(
          screen
            .getByRole('link', { name: 'Qualifier lâ€™action' })
            .getAttribute('href')
        ).toMatch(
          '/mes-jeunes/beneficiaire-1/actions/id-action-1/qualification?liste=beneficiaire'
        )
      })

      it('a11y', async () => {
        let results: AxeResults
        ;({ container } = renderWithContexts(
          <DetailActionPage
            action={actionAQualifier}
            jeune={jeune}
            lectureSeule={false}
            from='beneficiaire'
          />,
          {
            customConseiller: {
              structure: StructureConseiller.MILO,
            },
            customAlerte: { setter: alerteSetter },
          }
        ))

        await act(async () => {
          results = await axe(container)
        })

        expect(results!).toHaveNoViolations()
      })

      describe('quand le conseiller vient de la page pilotage', () => {
        it('affiche un lien pour qualifier lâ€™action qui retourne vers pilotage', () => {
          //When
          renderWithContexts(
            <DetailActionPage
              action={actionAQualifier}
              jeune={jeune}
              lectureSeule={false}
              from='pilotage'
            />,
            {
              customConseiller: {
                structure: StructureConseiller.MILO,
              },
              customAlerte: { setter: alerteSetter },
            }
          )

          //Then
          expect(
            screen
              .getByRole('link', { name: 'Qualifier lâ€™action' })
              .getAttribute('href')
          ).toMatch(
            '/mes-jeunes/beneficiaire-1/actions/id-action-1/qualification?liste=pilotage'
          )
        })
      })
    })

    describe("quand le conseiller n'est pas MiLo", () => {
      const actionAQualifier = uneAction({
        status: StatutAction.Terminee,
      })
      const jeune: BaseBeneficiaire & { idConseiller: string } = {
        id: 'beneficiaire-1',
        prenom: 'Nadia',
        nom: 'Sanfamiye',
        idConseiller: 'id-conseiller',
      }
      beforeEach(async () => {
        renderWithContexts(
          <DetailActionPage
            action={actionAQualifier}
            jeune={jeune}
            lectureSeule={false}
            from='beneficiaire'
          />,
          {
            customConseiller: { structure: StructureConseiller.POLE_EMPLOI },
          }
        )
      })

      it('ne permet pas de supprimer lâ€™action', () => {
        expect(
          screen.queryByRole('button', { name: 'Supprimer lâ€™action' })
        ).not.toBeInTheDocument()
      })
    })
  })

  describe("quand l'action qualifiÃ©e", () => {
    const jeune: BaseBeneficiaire & { idConseiller: string } = {
      id: 'beneficiaire-1',
      prenom: 'Nadia',
      nom: 'Sanfamiye',
      idConseiller: 'id-conseiller',
    }
    describe('qualifiÃ©e en SNP', () => {
      //Given
      const actionAQualifier = uneAction({
        status: StatutAction.Qualifiee,
        qualification: {
          libelle: 'Emploi',
          code: 'EMPLOI',
          isSituationNonProfessionnelle: true,
        },
      })

      //When
      beforeEach(async () => {
        ;(useRouter as jest.Mock).mockReturnValue({ push: routerPush })
        ;({ container } = renderWithContexts(
          <DetailActionPage
            action={actionAQualifier}
            jeune={jeune}
            lectureSeule={false}
            from='beneficiaire'
          />,
          {
            customConseiller: {
              structure: StructureConseiller.MILO,
            },
            customAlerte: { setter: alerteSetter },
          }
        ))
      })

      it('a11y', async () => {
        let results: AxeResults

        await act(async () => {
          results = await axe(container)
        })

        expect(results!).toHaveNoViolations()
      })

      it('affiche un encart dâ€™information de qualification en SNP', async () => {
        //Then
        expect(screen.getByText('Action qualifiÃ©e.')).toBeInTheDocument()
      })

      it('ne permet pas de modifier le statut de lâ€™action', () => {
        expect(screen.getByLabelText('Ã€ faire')).toHaveAttribute('disabled')
        expect(screen.getByLabelText('TerminÃ©e')).toHaveAttribute('disabled')
      })
    })

    describe('non qualifiÃ©e en SNP', () => {
      //Given
      const actionAQualifier = uneAction({
        status: StatutAction.Qualifiee,
        qualification: {
          libelle: 'Non SNP',
          code: 'NON_SNP',
          isSituationNonProfessionnelle: false,
        },
      })

      //When
      beforeEach(async () => {
        ;(useRouter as jest.Mock).mockReturnValue({ push: routerPush })
        ;({ container } = renderWithContexts(
          <DetailActionPage
            action={actionAQualifier}
            jeune={jeune}
            lectureSeule={false}
            from='beneficiaire'
          />,
          {
            customConseiller: {
              structure: StructureConseiller.MILO,
            },
            customAlerte: { setter: alerteSetter },
          }
        ))
      })

      it('a11y', async () => {
        let results: AxeResults

        await act(async () => {
          results = await axe(container)
        })

        expect(results!).toHaveNoViolations()
      })

      it('ne permet pas de modifier le statut de lâ€™action', () => {
        expect(screen.getByLabelText('Ã€ faire')).toHaveAttribute('disabled')
        expect(screen.getByLabelText('TerminÃ©e')).toHaveAttribute('disabled')
      })

      it('affiche un encart dâ€™information de qualification en SNP', async () => {
        //Then
        expect(
          screen.getByText(/Action qualifiÃ©e en non SNP/)
        ).toBeInTheDocument()
      })
    })
  })
})
